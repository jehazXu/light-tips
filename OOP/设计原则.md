### 面向对象设计7大原则

面向对象 设计模式

---


### 1. 单一职责原则（Single Responsibility Principle）

**<span style="color:red">一句话概括</span>**：每一个类应该专注于做一件事情。<br />
**<span style="color:red">高逼格专业描述：</span>** 是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因的话，以提高内聚性来减少引起变化的原因。不要为类实现过多的功能点，以保证类实体只有一个引起它变化的原因<br />

**<span style="color:red">非要多说一嘴：</span>** 单一职责原则不只是面向对象编程思想所特有的，只要是***模块化的程序设计，都适用单一职责原则***<br />

### 2. 里氏替换原则（Liskov Substitution Principle）

**一句话概括</span>**：超类/基类存在的地方，子类是可以替换的。【反之不一定可以】<br />
**<span style="color:red">高逼格专业描述：</span>** 子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。<br />
    里氏替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了里氏替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。<br />
    里氏替换原则是关于继承机制的设计原则，违反了里氏替换原则就必然导致违反开放封闭原则*【解释：实现开闭原则的关键是抽象化，而里氏代换原则中的基类和子类的继承关系正是抽象化的具体体现，所以里氏代换原则是对实现抽象化的具体步骤的规范。】*。<br />
    里氏替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。<br />
**<span style="color:red">非要多说一嘴：</span>**尽量使用精准的抽象类或者接口【子类和父类划分精准】，里氏代换原则是要求我们在使用继承时，必须满足一定的条件。不能为了复用，一味去继承。

### 3. 依赖倒置原则（Dependence Inversion Principle）

**<span style="color:red">一句话概括</span>**：实现尽量依赖抽象，不依赖具体实现。【可以映射为*活着与吃饭的关系*，活着不是为了吃饭，但是吃饭为了活着。】
**<span style="color:red">高逼格专业描述</span>：** 我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是**分离**接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而基础层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。<br />
**抽象的稳定性**决定了**系统的稳定性**，因为抽象是**不变的**，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。 <br />
    依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。**依赖于抽象，就是对面向接口编程，不要对实现编程**。
    
**<span style="color:red">非要多说一嘴：</span>**依赖倒置原则就是要求调用者和被调用者都依赖抽象，这样两者没有直接的关联和接触，在变动的时候，一方的变动不会影响另一方的变动。**面向抽象编程，解耦调用和被调用者**

### 4. 接口隔离原则（Interface Segregation Principle）

**<span style="color:red">一句话概括</span>**：应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。
**<span style="color:red">高逼格专业描述</span>：**接口隔离原则可以说是**单一职责的必要手段**，它的含义是尽量**使用职能单一的接口**，而不使用职能复杂、全面的接口。很好理解，接口是为了让子类实现的，如果**子类想达到职能单一**，那么**接口也必须满足职能单一**。相反，如果接口融合了多个不相关的方法，那它的子类就被迫要实现所有方法，尽管有些方法是根本用不到的。这就是**接口污染**。【大接口存在明显的弊端，会导致实现的类型必须完全实现该接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对大接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将大接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。】 
**<span style="color:red">非要多说一嘴</span>：** 拆分，从接口开始。

### 5. 迪米特法则（Law Of Demeter）

**<span style="color:red">一句话概括</span>**：又叫最少知识原则，一个对象对另一个对象知道的越少越好，即一个软件实体应当尽可能少的与其他实体发生相互作用。
**<span style="color:red">高逼格专业描述</span>：**迪米特原则要求尽量的封装，尽量的独立，尽量的使用低级别的访问修饰符。这是封装特性的典型体现。
一个类如果暴露太多私用的方法和字段，会让调用者很茫然。并且会给类造成不必要的判断代码。所以，我们使用尽量低的访问修饰符，让外界不知道我们的内部。这也是面向对象的基本思路。这是迪米特原则的一个特性，无法了解类更多的私有信息。
另外，迪米特原则要求类之间的直接联系尽量的少，两个类的访问，通过第三个中介类来实现。
**<span style="color:red">非要多说一嘴</span>：** 不和陌生人说话，有事去中介

### 6. 开闭原则（Open Close Principle）
**<span style="color:red">一句话概括</span>**：面向扩展/修改开放，面向修改关闭。
**<span style="color:red">高逼格专业描述</span>：** 其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。开放封闭原则主要体现在两个方面1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。
    实现开开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。
**<span style="color:red">非要多说一嘴</span>：**“需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。
一条放在第一位来理解，它的含义是对扩展开放，对修改关闭。解释一下就是，我们写完的代码，不能因为需求变化就修改。我们可以通过新增代码的方式来解决变化的需求。

 

当然，这是一种理想的状态，在现实中，我们要尽量的缩小这种修改。

 

再解释一下这条原则的意义所在，我们采用逆向思维方式来想。如果每次需求变动都去修改原有的代码，那原有的代码就存在被修改错误的风险，当然这其中存在有意和无意的修改，都会导致原有正常运行的功能失效的风险，这样很有可能会展开可怕的蝴蝶效应，使维护工作剧增。



说到底，开闭原则除了表面上的可扩展性强以外，在企业中更看重的是维护成本。

所以，开闭原则是设计模式的第一大原则，它的潜台词是：控制需求变动风险，缩小维护成本。


以下几种原则，都是为此原则服务的。

### 7. 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）

**<span style="color:red">一句话概括</span>**：尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。
**<span style="color:red">高逼格专业描述</span>：**

**<span style="color:red">非要多说一嘴</span>：**
此原则的含义是，如果只是达到代码复用的目的，尽量使用组合与聚合，而不是继承。这里需要解释一下，组合聚合只是引用其他的类的方法，而不会受引用的类的继承而改变血统。

 

继承的耦合性更大，比如一个父类后来添加实现一个接口或者去掉一个接口，那子类可能会遭到毁灭性的编译错误，但如果只是组合聚合，只是引用类的方法，就不会有这种巨大的风险，同时也实现了复用。

 

组合聚合复用原则的潜台词是：我只是用你的方法，我们不一定是同类。

 


因为：

其实整个设计模式就是在讲如何类与类之间的组合/聚合。在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。

如果为了复用，便使用继承的方式将两个不相干的类联系在一起，违反里氏代换原则，哪是生搬硬套，忽略了继承了缺点。继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用；虽然简单，但不安全，不能在程序的运行过程中随便改变；基类的实现发生了改变，派生类的实现也不得不改变；从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。

所以：

组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。


https://www.cnblogs.com/WuXuanKun/p/5386495.html

https://blog.csdn.net/qq_26296197/article/details/54849900


https://blog.csdn.net/littletigerat/article/details/7607864